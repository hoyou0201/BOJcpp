# 24956번: 나는 정말 휘파람을 못 불어

## 문제 요약
### 문제
휘파람을 불지 못하는 시루는 휘파람을 불기 위해 수없이 많이 시도했지만 항상 실패한다. 시루의 휘파람 연습을 도와주고 있는 루시는, 시루가 휘파람과 비슷한 소리를 낼 때마다 사탕을 주기로 했다.
시루의 입에서 나온 소리는 대문자로 구성된 문자열 $S$로 나타낼 수 있다. 루시는 문자열 $S$에서 휘파람과 비슷한 소리, 즉 '유사 휘파람 문자열'의 개수를 구해야 한다. '유사 휘파람 문자열'은 다음과 같이 정의한다.
WHEE는 '유사 휘파람 문자열'이다.
- '유사 휘파람 문자열' 뒤에 E를 붙인 것 또한 '유사 휘파람 문자열'이다.
- '유사 휘파람 문자열'은 문자열 $S$ 상에서 연속하지 않아도 된다. 즉, $S$에서 '유사 휘파람 문자열'인 부분 수열(subsequence)의 개수를 구하면 된다.

시루는 수없이 많이 시도했기 때문에 $S$의 길이가 너무 길어졌다. 루시를 도와 시루에게 사탕을 몇 개 줘야 할지 계산해주자.

### 사용 알고리즘
다이나믹 프로그래밍

### 입출력
- 입력: 첫째 줄에 문자열 $S$의 길이 $N$이 주어진다.
둘째 줄에 대문자로만 구성된 문자열 $S$가 주어진다.
- 출력: '유사 휘파람 문자열'인 부분 수열의 개수를 $1\,000\,000\,007(= 10^9+7)$로 나눈 나머지를 출력한다.
```
예제1

입력
8
WAHEWHEE
출력
6
```
## 풀이
dp를 쓰는 문제이다. 2차원으로 하나는 길이 하나는 각 끝 문자열의 개수를 쓴다. 이게 무슨 소리냐면 W가 가능한 개수와 WH가 가능한 개수 WHE가 가능한 개수, 유사휘파람 문자열이 가능한 개수를 다 구하는 것이다. 이전것의 개수를 가져온 다음 지금 문자열이 W면 W에 1추가 WH라면 WH에 W의 개수만큼 추가 이런식으로 하면 된다. 이때 마지막 유사휘파람 문자열은 유사휘파람 문자열에 WHE만 추가하면 되는것이 아니라 유사 휘파람 문자열을 한번 더 더해주어야 한다. 왜냐하면 유사휘파람 문자열은 추가로 들어온 E가 없어도 되고 있어도 되기에 2배가 되고 거기에 이전 WHE만큼 더해주면 된다.

## 어려웠던 점


## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MOD = 1e9+7;

int n;
string s;
vector<vector<long long>> dp;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n >> s;
    dp = vector<vector<long long>>(n+1, vector<long long>(4));

    dp[0] = {0,0,0,0};
    
    for (int i = 1; i < n+1; i++) {
        char c = s[i-1];
        dp[i] = dp[i-1];
        if(c == 'W'){
            dp[i][0] += 1;
        }
        else if(c == 'H'){
            dp[i][1] += dp[i-1][0];
        }
        else if(c == 'E'){
            dp[i][2] += dp[i-1][1];
            dp[i][3] += dp[i-1][2]+dp[i-1][3];
        }
        dp[i][0] %= MOD;
        dp[i][1] %= MOD;
        dp[i][2] %= MOD;
        dp[i][3] %= MOD;
    }

    cout << dp[n][3]%MOD;

    return 0;
}
```
