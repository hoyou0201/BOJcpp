# 14725번: 개미굴

## 문제 요약
### 문제
다음은 로봇 개미들이 윤수에게 보내준 정보다.

- KIWI BANANA
- KIWI APPLE
- APPLE APPLE
- APPLE BANANA KIWI

공백을 기준으로 왼쪽부터 순서대로 로봇 개미가 각 층마다 지나온 방에 있는 먹이 이름을 뜻한다.

윤수는 로봇 개미들이 보내준 정보를 바탕으로 다음과 같이 개미굴의 구조를 손으로 그려봤다.

```
APPLE
--APPLE
--BANANA
----KIWI
KIWI
--APPLE
--BANANA
```
개미굴의 각 층은 "--" 로 구분을 하였다. 또 같은 층에 여러 개의 방이 있을 때에는 사전 순서가 앞서는 먹이 정보가 먼저 나온다.

우리의 천재 공학자 윤수는 복잡한 개미굴들을 일일이 손으로 그리기 힘들어 우리에게 그려달라고 부탁했다.

한치 앞도 모르는 험한 이세상 그렇지만 오늘도 행복한 개미들!

행복의 비결을 알기 위해 윤수를 도와 개미굴이 어떤 구조인지 확인해보자.

### 사용 알고리즘
트리, dfs

### 입출력
- 입력: 첫 번째 줄은 로봇 개미가 각 층을 따라 내려오면서 알게 된 먹이의 정보 개수 N (1 ≤ N ≤ 1000)개가 주어진다.
두 번째 줄부터 N+1 번째 줄까지, 각 줄의 시작은 로봇 개미 한마리가 보내준 먹이 정보 개수 K (1 ≤ K ≤ 15)가 주어진다.
다음 K개의 입력은 로봇 개미가 왼쪽부터 순서대로 각 층마다 지나온 방에 있는 먹이 정보이며 먹이 이름 길이 t는 1 ≤ t ≤ 15를 만족한다. 먹이 정보는 알파벳 대문자로만 이루어져 있다.
- 출력: 개미굴의 시각화된 구조를 출력하여라.
개미굴의 각 층을 "--" 로 구분하며, 같은 층에 여러개의 방이 있을 때에는 사전 순서가 앞서는 먹이 정보가 먼저 나온다.
최상위 굴을 포함하여 하나의 굴에서 개미굴이 여러개로 나뉠 때 먹이 종류별로 최대 한 번만 나올 수 있다.
```
예제1

입력
3
2 B A
4 A B C D
2 A C
출력
A
--B
----C
------D
--C
B
--A
```
## 풀이
트리 구조를 만들어 dfs로 출력하는 문제이다. 각 개미는 한 가지 경로로 가므로 한 개미의 입력들은 항상 한칸씩 깊어지며 들어온다. 개미굴은 트리구조이므로 그것을 만들어 풀면 된다.

## 어려웠던 점
자료구조를 짜서 하면 쉬웠겠지만 그냥 있는걸로 풀려니까 헷갈리고 어려웠다. struct를 더 공부해야겠다는 생각을 했다.

## 배운 점 / 느낀 점
map과 unordered_map의 차이점을 알고 정렬을 커스텀 하는 방법을 알았다.

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <unordered_map>
using namespace std;

vector<string> num;


struct Cmp{
    bool operator()(int a, int b) const {
        return num[a] < num[b];
    }
};


vector<unordered_map<int, set<int, Cmp>>> g;
unordered_map<int, unordered_map<string, int>> name;

int n, m, t, tt, na;
string s;

void dfs(int d, int k){
    if(g.size() <= d || g[d].count(k) == 0){
        return;
    }
    for (int i : g[d][k]) {
        for (int j = 0; j < d; j++) {
            cout << "--";
        }
        cout << num[i] << '\n';
        dfs(d+1, i);
    }
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    
    name = unordered_map<int, unordered_map<string, int>>();
    num = vector<string>();
    for (int i = 0; i < n; i++) {
        cin >> m;
        tt = -1;
        for (int j = 0; j < m; j++) {
            if(g.size() == j){
                g.push_back(unordered_map<int, set<int, Cmp>>());
            }
            cin >> s;
            if(name[tt].count(s)){
                tt = name[tt][s];
            }
            else{
                name[tt][s] = num.size();
                num.push_back(s);
                g[j][tt].insert(name[tt][s]);
                tt = name[tt][s];
            }
        }
    }

    dfs(0, -1);

    return 0;
}
```
