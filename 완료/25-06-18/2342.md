# 2342번: 

## 문제 요약
### 문제
십자가의 형태로 있는 발판이 있는데 두 발을 사용해서 입력된 순으로 발판을 밟아야한다. 두 발이 같은 곳에 위치하면 안된다. 현재위치의 발판을 다시누르는건 1, 시작지점에서 아무 발판으로 이동해 누르는건 2, 인접한 발판으로 이동하여 누르는건 3, 반대편 발판으로 이동하여 누르는건 4의 힘이 들때 최소값을 찾아라

### 사용 알고리즘
다이나믹 프로그래밍

### 입출력
- 입력: 눌러야할 순서, 0이나오면 입력 종료
- 출력: 최소값
```
예제1

입력
1 2 2 4 0
출력
8
```
## 풀이
dp로 푸는 문제이다. `dp[step][left][right]`배열을 만들어서 스탭 한번당 가능한 경우의 수를 모두 저장한다. dp인 이유는 언뜻 보면 모든 경우의 수를 저장하는것 같이 보이지만 가능한 모든 발의 조합의 경우의 수만 저장하고 있고, 겹치는 발의 조합이 나오면 최소값을 가져온다. dp를 사용하지 않고 모든 조합을 하면 `O(2^n)`이 되었을 것이다.

## 어려웠던 점
처음 접근할때 dp의 중간지점을 잡을때 과거 왼발을 움직였는지 오른발을 움직였는지 2개로 잡았는데 완전 틀린 접근이었다. dp를 저렇게 많이 잡아서 사용할 수 있다는것도 생각하게 되었다. 중간에 매우 많이 틀렸었던 문제인데 발의 움직임 값을 계산하는 함수에서 인접한 발판으로 이동하는 if문에서 둘의 차가 1일때만 넣어놨는데 3일때도 넣었어야 했다. 내가 푼 모든 테스트 케이스가 1일때만 넣어도 풀어져서 찾는데 고생했다. 당연히 비교함수는 맞을줄 알고 dp부분만 계속 고치고 있었는데 앞으로는 확실히 체크해야겠다. 

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#define INF 1000000000
#define MAX 100009
using namespace std;

vector<int> a;
int dp[MAX][5][5];

int comp(int b, int c){
    if(b == 0){
        return 2;
    }
    else if(abs(b-c) == 1 ||abs(b-c) == 3){
        return 3;
    }
    else if(b==c){
        return 1;
    }
    else{
        return 4;
    }
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t;
    a = vector<int>();

    while(true){
        cin >> t;
        if(t == 0){
            break;
        }
        else{
            a.push_back(t);
        }
    }

    for (int i = 0; i < a.size()+3; i++) {
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 5; k++) {
                dp[i][j][k] = INF;
            }
        }
    }
    dp[0][0][0] = 0;

    for (int i = 0; i < a.size(); i++) {
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 5; k++) {
                if(dp[i][j][k] == INF){
                    continue;
                }
                int next = a[i];
                if (next != k) {
                    dp[i+1][next][k] = min(dp[i+1][next][k], dp[i][j][k] + comp(j, next));
                }
                if (next != j) {
                    dp[i+1][j][next] = min(dp[i+1][j][next], dp[i][j][k] + comp(k, next));
                }
                
            }
        }
    }

    int m = INF;
    for (int j = 0; j < 5; j++) {
        for (int k = 0; k < 5; k++) {
            m = min(m,dp[a.size()][j][k]);
        }
    }
    cout << m;
    
    return 0;
}
```
