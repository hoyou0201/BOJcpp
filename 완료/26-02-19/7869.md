# 7869번: 두 원

## 문제 요약
### 문제
두 원이 주어졌을 때, 교차하는 영역의 넓이를 소수점 셋째자리까지 구하는 프로그램을 작성하시오.

### 사용 알고리즘
수학, 기하학

### 입출력
- 입력: 첫째 줄에 두 원의 중심과 반지름 x1, y1, r1, x2, y2, r2가 주어진다. 실수는 최대 소수점 둘째자리까지 주어진다.
- 출력: 첫째 줄에 교차하는 영역의 넓이를 반올림해 소수점 셋째자리까지 출력한다.
```
예제1

입력
20.0 30.0 15.0 40.0 30.0 30.0
출력
608.366
```
## 풀이
완전히 겹치거나 완전히 겹치지 않는 경우는 쉬우니 그냥 풀면 되고, 일부분만 겹치는 경우가 문제다. 이때는 겹치는 부분을 반으로 쪼개 각 원의 원활로 만든다. 이 원활은 부채꼴에서 삼각형을 뺀 부분의 넓이와 같다. 부채꼴은 각도를 코사인 법칙을 이용해 구해서 구하면 되고, 삼각형은 두 삼각형을 합쳐서 가로로 다시 나누면 같은 크기의 삼각형 2개가 된다. 이 삼각형을 헤론 형태를 이용해 풀면 된다.

## 어려웠던 점
수학 공식이 많이 나와서 어려웠다.

## 배운 점 / 느낀 점
수학 공식을 알아두어야 겠다고 생각했다.

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;

struct circle{
    double x, y, r;
};

const double eps = 1e-10;
const double PI = acos(-1);

circle a, b;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> a.x >> a.y >> a.r;
    cin >> b.x >> b.y >> b.r;

    double d = sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));

    if(d >= a.r+b.r-eps){
        cout << fixed << setprecision(3) << 0.0;
    }
    else if (d <= fabs(a.r-b.r)+eps){
        circle k = a;
        if(a.r > b.r) k = b;
        double x = k.r*k.r*PI;
        cout << fixed << setprecision(3) << x;
    }
    else{
        double ar = acos(((a.r*a.r)+(d*d)-(b.r*b.r))/(2*a.r*d));
        double br = acos(((b.r*b.r)+(d*d)-(a.r*a.r))/(2*b.r*d));

        double x = a.r*a.r*ar+b.r*b.r*br-0.5*sqrt((a.r+b.r+d)*(a.r-b.r+d)*(a.r+b.r-d)*(b.r+d-a.r));

        cout << fixed << setprecision(3) << x;
    }

    return 0;
}
```
