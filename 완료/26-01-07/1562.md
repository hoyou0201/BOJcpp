# 1562번: 계단 수

## 문제 요약
### 문제
45656이란 수를 보자.
이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.
N이 주어질 때, 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. 0으로 시작하는 수는 계단수가 아니다.

### 사용 알고리즘
다이나믹 프로그래밍

### 입출력
- 입력: 첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
- 출력: 첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.
```
예제1

입력
10
출력
1
```
## 풀이
dp문제인데 3차원을 써야 한다. 비트마스크도 써야 한다. 일단 축들은 당연히 숫자의 길이가 들어가고, 마지막 숫자에 +1하거나 -1인 숫자가 추가되는 것이므로 마지막 숫자가 들어간다. 또한 0~9까지 다 썼는지 확인해야 하므로 비트마스크가 들어가야 한다. 값은 그런 숫자가 몇개인지가 들어간다. 일단 각축들을 돌리는 3중for문을 작성해야 한다. 비트마스크 for문은 $1$~$1^{10}-1$까지 돌려야 한다. 

## 어려웠던 점
dp는 항상 아이디어가 어렵다. 처음 축을 잡아야하는 것을 모르겠었다. 비트마스크 for문을 돌릴때 아무 생각 없이 1<<=1을 써서 for문을 돌았는데 생각해보니까 모든 비트마스크 조합을 거쳐야 답이 나온다.

## 배운 점 / 느낀 점
비트마스크를 조금 더 잘 하게 되었다.

## 재풀이 후기
살짝 막혔지만 결국 풀었다. 한번 더 풀어야 할 필요성을 느꼈다. dp for문을 돌릴때 새로 구할 것이 아니라 이전것을 기준으로 생각하고 푸니까 좀더 쉬웠다.

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

long long dp[101][10][1<<10];

int n;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;

    //dp초기값
    for (int i = 1; i < 10; i++) {
        dp[1][i][1<<i] = 1;
    }


    for (int i = 1; i < n; i++) {
        for (int j = 0; j < 10; j++) {
            for(int k = 1; k < 1<<10; k+= 1){
                if(j < 9){
                    dp[i+1][j][k|1<<j] += dp[i][j+1][k];
                    dp[i+1][j][k|1<<j] %= 1000000000;
                }
                if(j > 0){
                    dp[i+1][j][k|1<<j] += dp[i][j-1][k];
                    dp[i+1][j][k|1<<j] %= 1000000000;
                }
            }
        }
        
    }
    long long r = 0;
    for(int j = 0; j < 10; j++){
        r += dp[n][j][(1<<10)-1];
        r %= 1000000000;
    }
    cout << r;


    return 0;
}
```
