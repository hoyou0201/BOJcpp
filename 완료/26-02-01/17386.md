# 17386번: 선분 교차 1

## 문제 요약
### 문제
2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구해보자.

L1의 양 끝 점은 (x1, y1), (x2, y2), L2의 양 끝 점은 (x3, y3), (x4, y4)이다.

### 사용 알고리즘
ccw

### 입출력
- 입력: 첫째 줄에 L1의 양 끝 점 x1, y1, x2, y2가, 둘째 줄에 L2의 양 끝 점 x3, y3, x4, y4가 주어진다. 세 점이 일직선 위에 있는 경우는 없다.
- 출력: L1과 L2가 교차하면 1, 아니면 0을 출력한다.
```
예제1

입력
1 1 5 5
1 5 5 1
출력
1
```
## 풀이
ccw를 활용하는 문제이다. a와 b 선분에서 ccw를 c와 d에 대해 할 경우 둘의 값의 곱이 음수이면 둘은 반대편에 있다. 하지만 a와 b가 모두 c와 d의 같은 편에 있으면 교차하지 않으므로 둘도 ccw판정을 해야 한다.

## 어려웠던 점


## 배운 점 / 느낀 점
ccw를 알게 되었다.
ccw를 한쪽 선분만 하면 안되고 두개의 선분 모두 해야 한다.

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Point{
    long long x;
    long long y;
};

Point a, b, c, d;

int ccw(Point a, Point b, Point c){
    long long k = (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);
    if(k < 0) return -1;
    else return 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> d.x >> d.y;
    if(ccw(a,b,c)*ccw(a,b,d) == -1 && ccw(c,d,a)*ccw(c,d,b) == -1){
        cout << 1;
    }
    else{
        cout << 0;
    }

    return 0;
}
```
