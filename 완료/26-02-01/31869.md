# 31869번: 선배님 밥 사주세요!

## 문제 요약
### 문제
24학번 신입생 정민이는 밥을 사준다는 선배들의 약속을 모두 메모장에 기록해 둔다. 메모장의 각 줄에는 선배 이름 $S$, 약속 주차 $W$, 요일 $D$, 밥 약속에 드는 비용 $P$가 기록돼 있다. 선배 이름은 문자열, 나머지는 정수로 기록한다. 또, 한 선배는 두 번 이상 밥을 사주지 않으며 모든 선배의 이름은 다르다.

정민이는 컴퓨터학부답게 요일을 $0$과 $6$ 사이의 정수로 기록한다. 예를 들어 월요일은 $0$이고 목요일은 $3$이다.

정민이의 착한 선배들은 밥을 사줄 수 있는 충분한 돈이 있다면 귀여운 후배와의 밥 약속을 무를 수 없다. 정민이의 기록과 선배들이 지닌 돈을 보고 정민이가 최대 며칠 연속으로 밥을 얻어먹을 수 있는지 구해보자!

### 사용 알고리즘


### 입출력
- 입력: 첫 번째 줄에는 기록의 수 $N$이 주어진다. ($0 \leq N \leq 100$)
두 번째 줄부터 $N$개의 줄에 걸쳐 기록의 정보가 주어진다. 기록의 정보는 $S$ $W$ $D$ $P$와 같은 형식으로 주어지며, 이는 $S$선배가 $W$주차 $D$번째 요일에 $P$원이 필요한 밥 약속을 잡았음을 뜻한다. 기록에 있는 선배의 이름은 모두 정확히 한 번씩만 주어진다. 
$(1 \leq W \leq 10; 0 \leq D \leq 6; 0 \leq P \leq 100\,000)$ 
그다음 줄부터 $N$개의 줄에 걸쳐 앞서 주어진 선배 이름과 선배가 소지한 돈 $M$이 공백을 사이에 두고 주어진다. 여기서 주어지는 선배 이름의 순서는 앞서 주어진 선배 이름의 순서와 다를 수 있다. $(0 \leq M \leq 100\,000)$ 
선배 이름은 $12$글자 이내의 영어 대소문자로 이뤄진 문자열로 주어진다.
- 출력: 정민이가 최대 며칠 연속으로 밥을 얻어먹을 수 있는지 출력한다.
```
예제1

입력
3
OhIkjun 1 6 10000
Hyukjun 1 5 5000
Junseong 2 0 8000
Hyukjun 4000
OhIkjun 12000
Junseong 20000
출력
2
```
## 풀이
해시 맵을 이용하는 문제이다. 일단 주차와 요일로 나눠져있는 날짜 개념을 주차에 7을 곱하고 요일을 더해 알기 쉽게 바꿨다. 그리고 맵에 이름을 키로 하고 값에 날짜와 돈을 넣었다. 다음 for문에서는 현재 돈을 비교하며 살수 있는 능력이 되는 사람의 날짜만 queue에 넣었다. 우선 순위 큐를 사용하여 자동으로 내림차순 정렬을 하였고 연속되는 날짜를 찾았다.

## 어려웠던 점
- 큐를 오름차순이라 생각하고 풀었다.

## 배운 점 / 느낀 점
중복 제거에 unique함수를 써서 다시 풀어보자

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <queue>
using namespace std;

int n;
unordered_map<string, pair<int,int>> jigab;
priority_queue<int> q;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    for (int i = 0; i < n; i++) {
        string s;
        int w, d, p;
        cin >> s >> w >> d >> p;
        jigab[s] = {w*7+d, p};
    }
    for (int i = 0; i < n; i++) {
        string s;
        int m;
        cin >> s >> m;
        if(jigab[s].second <= m){
            q.push(jigab[s].first);
        }
    }
    int max_r = 0;
    int r = 0;
    int tt = -1;
    while(!q.empty()){
        int day = q.top();
        q.pop();
        if(tt -1 == day){
            r++;
        }
        else if(tt == day){
            
        }
        else{
            max_r = max(r, max_r);
            r = 1;
        }
        tt = day;
    }
    cout << max(max_r, r);
    return 0;
}
```
