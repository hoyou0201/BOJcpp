# 19940번: 

## 문제 요약
### 문제
피자를 굽는 전자식 오븐이 있다. 이 오븐에 재료는 넣고 정확히 $N$분 동안 동작을 시키고자 한다. 그런데 이 오븐에 준비된 버튼은 아래와 같은 동작을 하는 5가지이다. 즉, 각각의 버튼은 동작 시간을 추가시키거나 감소시킨다. 처음에 피자 오븐의 첫 시간은 0분으로 정해져 있다. 시간을 감소시키는 버튼을 눌러서 시간이 0분보다 작아지는 경우에는 0분으로 설정된다. $t$가 현재 오븐에 세팅된 시간, $t'$은 버튼을 누른 뒤의 시간을 의미할 때, 각 버튼은 다음과 같은 기능을 가지고 있다.
- ADDH: $t' = t + 60$ 
- ADDT: $t' = t + 10$ 
- MINT: $t' = t - 10$ 
- ADDO: $t' = t + 1$ 
- MINO: $t' = t - 1$ 
예를 들어, 58분을 설정하고 싶으면, ADDO (+1분) 버튼을 58번 눌러도 된다. 하지만, ADDH (+60분) 버튼을 한 번 누른 뒤에 MINO (-1분) 버튼을 2번 누르면 3번의 작업으로 58분을 만들 수 있다. 42분을 설정하고 싶은 경우에는 버튼을 ADDH, MINT, MINT, ADDO, ADDO 순서로 5번 눌러서 만들 수 있다. ADDT, ADDT, ADDT, ADDT, ADDO, ADDO 순서로 6번 눌러서 만들 수 있지만, 버튼은 최소 횟수로 누르려고 한다.
설정해야 할 시간이 주어졌을 때, 그 시간을 만들기 위해 눌러야 하는 버튼의 최소 횟수와 그 방법을 구하는 프로그램을 작성하시오.

### 사용 알고리즘
bfs, 그리디

### 입출력
- 입력: 입력을 $T$개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 설정해야 하는 시간 $N$이 분 단위의 정수로 주어진다.
- 출력: 각각의 테스트 케이스마다 5개의 정수를 한 줄에 공백으로 구분해서 출력한다. 이 정수는 입력으로 주어진 시간을 만들기 위해서 ADDH, ADDT, MINT, ADDO, MINO 버튼을 누르는 횟수를 출력한 것이다. 최소 횟수로 누르는 방법이 여러가지인 경우에는 사전 순으로 가장 앞서는 방법을 출력한다.
작업 횟수가 동일한 방법이 여러가지가 있을 때, ADDH를 누르는 횟수가 적은것이 사전 순으로 앞서는 것이고, ADDH를 누르는 횟수가 동일하면, ADDT를 누르는 횟수가 적은것이 먼저이다. ADDT를 누르는 횟수가 동일하면 MINT를 누르는 횟수가 적은것이, MINT를 누르는 횟수가 동일하면 ADDO를 누르는 횟수가 적은것이, ADDO를 누르는 횟수가 동일하면 MINO를 누르는 횟수가 적은것이 사전 순으로 앞서는 것이다.
```
예제1

입력
3
5
12
27
출력
0 0 0 5 0
0 1 0 2 0
0 3 0 0 3
```
## 풀이
먼저 60을 최대한 빼는건 항상 맞다. 60이상의 숫자에서 가장빠르게 60을 빼는 경우는 하나밖에 없기 때문이다. 이후 남은 0~59가 문제인데 이정도는 bfs를 통해 미리 구해두면 된다.

## 어려웠던 점
코드를 살짝 더럽게 짠거 같다.

## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int T, n;

vector<int> timer;
vector<vector<int>> best;
vector<bool> visit;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> T;

    queue<pair<int,vector<int>>> q;
    best = vector<vector<int>>(61);
    visit = vector<bool>(61);

    q.emplace(1, vector<int>{0,0,0,1,0});
    q.emplace(10, vector<int>{0,1,0,0,0});
    q.emplace(60, vector<int>{1,0,0,0,0});
    best[0] = {0,0,0,0,0};
    while(!q.empty()){
        auto [a, v] = q.front();
        q.pop();
        if(!visit[a]){
            visit[a] = true;
            best[a] = v;
            if(a-1 > 0){
                v[4]+=1;
                q.emplace(a-1, v);
                v[4]-=1;
            }
            if(a+1 < 61){
                v[3]+=1;
                q.emplace(a+1, v);
                v[3]-=1;
            }
            if(a-10 > 0){
                v[2]+=1;
                q.emplace(a-10, v);
                v[2]-=1;
            }
            if(a+10 < 61){
                v[1]+=1;
                q.emplace(a+10, v);
                v[1]-=1;
            }
        }
    }



    for(int _ = 0; _ < T; _++){
        cin >> n;


        int gh = n / 60;
        n %= 60;

        cout << best[n][0]+gh << ' ';
        for(int i = 1; i < 5; i++){
            cout << best[n][i] << ' ';
        }
        cout << '\n';



    }

    return 0;
}
```
