# 15710번: xor 게임

## 문제 요약
### 문제
chogahui05는 xor 게임을 하고 있다. 이 게임은 n개의 턴 동안 진행되며, 정수 0 ~ 231 - 1가 적혀있는 무한히 많은 카드를 가지고 진행하는 재밌는 게임이다. 이 게임의 규칙은 다음과 같다.
- chogahui05는 처음에 정수 a가 적힌 카드를 가지고 시작한다. 
- 매 턴마다, chogahui05는 아래와 같은 작업을 수행해야 한다.
- 0 ≤ u < 231을 만족하는 정수 u를 하나 고른다.
- 현재 가지고 있는 카드를 num이라고 했을 때, 현재 가지고 있는 카드를 num (xor) u의 결과값이 적힌 카드로 교체한다.
- 게임을 마치고, chogahui05가 들고 있는 카드에 적혀 있는 수는 b가 되었다.
이때 게임의 과정으로 가능한 경우의 수를 1000000007(109 + 7)로 나눈 나머지를 출력하라.

### 사용 알고리즘
분할 정복

### 입출력
- 입력: 첫째 줄에 정수 a, b (0 ≤ a, b < 231), n(0 < n ≤ 109)이 공백으로 구분되어 주어진다. 
- 출력: Chogahui05가 가지고 있던 정수 a가 적힌 카드가 게임이 끝나고 b가 적힌 카드가 되었을 때, 게임의 과정으로 가능한 경우의 수를 1000000007(109 + 7)로 나눈 나머지를 출력하라.
```
예제1

입력
2 3 1
출력
1
```
## 풀이
사실 xor은 역원이 존재하는 연산이기에 마지막 값이 나오기 위해서 x라는 특정한 값으로 연산을 하였을때 원래 값은 정해져있다. 따라서 n턴안에 b를 만들기 위해서는 마지막 턴에만 제대로 된 연산을 하면 된다. 각 턴마다 가능한 경우의 수는 2^31개 이고 마지막 턴에만 b를 만들기 위한 하나의 값인 1개가 된다. 따라서 이 문제는 2^31의 거듭제곱을 얼마나 빠르게 할 수 있는지에 대한 문제이다. 이는 분할 정복을 이용하여 거듭제곱을 반으로 나누는 식으로 풀면 된다.

## 어려웠던 점


## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

long long a, b, n;
const long long MOD = 1000000007;
const long long T = (1LL<<31) % MOD;

long long powmod(long long base, long long exp){
    if (exp == 0){
        return 1;
    }
    else if(exp == 1){
        return base%MOD;
    }
    long long k = powmod(base, exp/2);
    k = (k*k)%MOD;
    if(exp%2) k = (k*base)%MOD;
    return k;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> a >> b >> n;

    long long k = 1;


    cout << powmod(T, n-1);

    return 0;
}
```
