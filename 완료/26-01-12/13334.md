# 13334번: 철로

## 문제 요약
### 문제
집과 사무실을 통근하는 n명의 사람들이 있다. 각 사람의 집과 사무실은 수평선 상에 있는 서로 다른 점에 위치하고 있다. 임의의 두 사람 A, B에 대하여, A의 집 혹은 사무실의 위치가 B의 집 혹은 사무실의 위치와 같을 수 있다. 통근을 하는 사람들의 편의를 위하여 일직선 상의 어떤 두 점을 잇는 철로를 건설하여, 기차를 운행하려고 한다. 제한된 예산 때문에, 철로의 길이는 d로 정해져 있다. 집과 사무실의 위치 모두 철로 선분에 포함되는 사람들의 수가 최대가 되도록, 철로 선분을 정하고자 한다.
양의 정수 d와 n 개의 정수쌍, (hi, oi), 1 ≤ i ≤ n,이 주어져 있다. 여기서 hi와 oi는 사람 i의 집과 사무실의 위치이다. 길이 d의 모든 선분 L에 대하여, 집과 사무실의 위치가 모두 L에 포함되는 사람들의 최대 수를 구하는 프로그램을 작성하시오.
그림 1 에 있는 예를 고려해보자. 여기서 n = 8, (h1, o1) = (5, 40), (h2, o2) = (35, 25), (h3, o3) = (10, 20), (h4, o4) = (10, 25), (h5, o5) = (30, 50), (h6, o6) = (50, 60), (h7, o7) = (30, 25), (h8, o8) = (80, 100)이고, d = 30이다. 이 예에서, 위치 10 과 40 사이의 빨간색 선분 L이, 가장 많은 사람들에 대하여 집과 사무실 위치 모두 포함되는 선분 중 하나이다. 따라서 답은 4 이다.

### 사용 알고리즘


### 입출력
- 입력: 입력은 표준입력을 사용한다. 첫 번째 줄에 사람 수를 나타내는 양의 정수 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 각 줄에 정수 쌍 (hi, oi)가 주어진다. 여기서 hi와 oi는 −100,000,000이상, 100,000,000이하의 서로 다른 정수이다. 마지막 줄에, 철로의 길이를 나타내는 정수 d (1 ≤ d ≤ 200,000,000)가 주어진다.
- 출력: 출력은 표준출력을 사용한다. 길이 d의 임의의 선분에 대하여, 집과 사무실 위치가 모두 그 선분에 포함되는 사람들의 최대 수를 한 줄에 출력한다. 
```
예제1

입력
8
5 40
35 25
10 20
10 25
30 50
50 60
30 25
80 100
30
출력
4
```
## 풀이
먼저 선분의 뒤의 값으로 오름차순으로 정렬한다. 철로의 끝을 정렬한 것중 앞에꺼부터 하나씩 가져오며 거기에 대응시킨다. 철로의 앞쪽 끝 안쪽에 있는지 확인하려면 선분의 뒤의 값을 가져온 것들은 다시 앞의 값들을 오름차순으로 정렬하여 하나씩 넣는다. 그리고 하나씩 가져오며 안쪽에 있는지 확인한다. 없으면 pop하고 있으면 숫자를 센다.

## 어려웠던 점
뒤쪽부터 접근하는 아이디어가 쉽지 않았다.

## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <stack>
#include <functional>
using namespace std;


int n, h, o, d, result;
priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> lines;
priority_queue<int, vector<int>, greater<int>> q;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> h >> o;
        if(h > o) lines.push({h, o});
        else lines.push({o, h});
    }

    cin >> d;

    while(!lines.empty()){
        pair<int, int> a = lines.top();
        lines.pop();
        if(a.first - a.second > d) continue;
        q.push(a.second);
        while(!q.empty() && q.top() < a.first-d){
            q.pop();
        }
        result = max((int)q.size(), result);
    }
    cout << result;



    return 0;
}
```
