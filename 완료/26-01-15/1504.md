# 1504번: 특정한 최단 경로

## 문제 요약
### 문제
방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.
세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.

### 사용 알고리즘
다익스트라

### 입출력
- 입력: 첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1) 임의의 두 정점 u와 v사이에는 간선이 최대 1개 존재한다.
- 출력: 첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.
```
예제1

입력
4 6
1 2 3
2 3 3
3 4 1
1 3 5
2 4 5
1 4 4
2 3
출력
7
```
## 풀이
다익스트라를 사용하면 쉽게 풀 수 있다. 먼저 가능한 경로는 1 -> v1 -> v2 -> n과 1 -> v2 -> v1 -> n밖에 없다. 따라서 이 두 경우를 모두 구하면 된다. 일단 1에서 v1과 v2까지의 거리를 구하고 v1에서 v2와 n까지의 거리, v2에서 v1까지와 n까지의 거리를 구한다. 그리고 그것을 조합하여 거리를 구하면 된다.

## 어려웠던 점
경로에 도달하지 못하는 경우를 처리하는게 살짝 까다로웠고, 다익스트라가 오랜만에 써서 익숙치 않았다.

## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int n, e, a, b, c, v1, v2;

vector<vector<int>> graph;
vector<long> tov1;
vector<long> v1to;
vector<long> v2to;
vector<bool> visit;
priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> qv1;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n >> e;

    graph = vector<vector<int>>(n+1, vector<int>(n+1));

    for (int i = 0; i < e; i++){
        cin >> a >> b >> c;
        graph[a][b] = c;
        graph[b][a] = c;
    }
    cin >> v1 >> v2;

    tov1 = vector<long>(n+1, 1e9);
    tov1[1] = 0;
    qv1.push({0,1});
    bool bv1 = false;
    bool bv2 = false;
    visit = vector<bool>(n+1, false);
    while(!qv1.empty()){
        auto [t, v] = qv1.top();
        qv1.pop();
        if(visit[v]){
            continue;
        }
        if(v == v1) bv1 = true;
        if(v == v2) bv2 = true;
        if(bv1 && bv2) break;
        visit[v] = true;
        for (int i = 1; i < n+1; i++) {
            if(graph[v][i] != 0 && !visit[i]){
                tov1[i] = min(tov1[i], (long)tov1[v]+graph[v][i]);
                qv1.push({tov1[i], i});
            }
        }
    }
    qv1 = priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>();
    v1to = vector<long>(n+1, 1e9);
    v1to[v1] = 0;
    qv1.emplace(0, v1);
    bv1 = false;
    bv2 = false;
    visit = vector<bool>(n+1, false);
    while(!qv1.empty()){
        auto [t, v] = qv1.top();
        qv1.pop();
        if(visit[v]){
            continue;
        }
        if(v == n) bv1 = true;
        if(v == v2) bv2 = true;
        if(bv1 && bv2) break;
        visit[v] = true;
        for (int i = 1; i < n+1; i++) {
            if(graph[v][i] != 0 && !visit[i]){
                v1to[i] = min(v1to[i], (long)v1to[v]+graph[v][i]);
                qv1.emplace(v1to[i], i);
            }
        }
    }
    qv1 = priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>();
    v2to = vector<long>(n+1, 1e9);
    v2to[v2] = 0;
    qv1.emplace(0, v2);
    bv1 = false;
    bv2 = false;
    visit = vector<bool>(n+1, false);
    while(!qv1.empty()){
        auto [t, v] = qv1.top();
        qv1.pop();
        if(visit[v]){
            continue;
        }
        if(v == n) bv1 = true;
        if(v == v1) bv2 = true;
        if(bv1 && bv2) break;
        visit[v] = true;
        for (int i = 1; i < n+1; i++) {
            if(graph[v][i] != 0 && !visit[i]){
                v2to[i] = min(v2to[i], (long)v2to[v]+graph[v][i]);
                qv1.emplace(v2to[i], i);
            }
        }
    }
    if((long)tov1[v1]+v1to[v2]+v2to[n] > (long)tov1[v2]+v2to[v1]+v1to[n]){
        if((long)tov1[v2]+v2to[v1]+v1to[n] >= 1e9){
            cout << -1;
            return 0;
        }
        cout << (long)tov1[v2]+v2to[v1]+v1to[n];
    }
    else{
        if((long)tov1[v1]+v1to[v2]+v2to[n] >= 1e9){
            cout << -1;
            return 0;
        }
        cout << (long)tov1[v1]+v1to[v2]+v2to[n];
    }

    return 0;
}
```
