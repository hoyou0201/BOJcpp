# 1708번: 볼록 껍질

## 문제 요약
### 문제
다각형의 임의의 두 꼭짓점을 연결하는 선분이 항상 다각형 내부에 존재하는 다각형을 볼록 다각형이라고 한다. 아래 그림에서 (a)는 볼록 다각형이며, (b)는 볼록 다각형이 아니다.
조금만 생각해 보면 다각형의 모든 내각이 180도 이하일 때 볼록 다각형이 된다는 것을 알 수 있다. 편의상 이 문제에서는 180도 미만인 경우만을 볼록 다각형으로 한정하도록 한다.
2차원 평면에 N개의 점이 주어졌을 때, 이들 중 몇 개의 점을 골라 볼록 다각형을 만드는데, 나머지 모든 점을 내부에 포함하도록 할 수 있다. 이를 볼록 껍질 (CONVEX HULL) 이라 한다. 아래 그림은 N=10인 경우의 한 예이다.
점의 집합이 주어졌을 때, 볼록 껍질을 이루는 점의 개수를 구하는 프로그램을 작성하시오.

### 사용 알고리즘
ccw

### 입출력
- 입력: 첫째 줄에 점의 개수 N(3 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 점의 x좌표와 y좌표가 빈 칸을 사이에 두고 주어진다. 주어지는 모든 점의 좌표는 다르다. x좌표와 y좌표의 범위는 절댓값 40,000을 넘지 않는다. 입력으로 주어지는 다각형의 모든 점이 일직선을 이루는 경우는 없다.
- 출력: 첫째 줄에 볼록 껍질을 이루는 점의 개수를 출력한다.
볼록 껍질의 변에 점이 여러 개 있는 경우에는 가장 양 끝 점만 개수에 포함한다.
```
예제1

입력
8
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
출력
5
```
## 풀이
ccw를 활용하는 문제이다. 볼록껍질의 각 선분이 같은 방향으로 진행하여 돌고 있다고 가정할때 ccw를 적용하면 각 선분에 대하여 모든 점은 같은 방향에 있다. 이를 활용하여 풀 수 있다. 먼저 x와 y를 기준으로 정렬한다. 그렇다면 가장 처음과 가장 끝은 항상 볼록 껍질에 속하게 된다. 따라서 그 점부터 시작하여 모든 점을 한칸씩 탐색을 한다. 먼저 정렬된 순으로 vector에 값을 추가한다. 이때 그 백터의 이전 두개의 점과 새로 넣을 점에 대하여 ccw를 적용한다. 가운데 점이 안에 있다면(vector에는 볼록 껍질의 꼭지점이 들어가야 하는데 안쪽의 점은 볼록껍질의 꼭지점이 아니다.) 그 점을 없애고 다시 두개의 점과 새로 넣을 점에 대하여 반복한다. 만약 두개의 점이 남지 않거나 중간 점이 바깥의 점이라면 다음 새로운 점에 대하여 반복한다. 하지만 이렇게 하면 왼쪽 아래에서 시작하여 오른쪽 위로 가는 아래의 볼록껍질 밖에 만들지 못한다. 따라서 정렬된 순의 역순으로 시작하여 위 과정을 반복하면 위껍질도 만들수 있어서 합치면 된다.

## 어려웠던 점
볼록 껍질을 두개로 나눠서 구하는 아이디어가 어려웠다.

## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

struct Point {
    long long x, y;

    bool operator<(const Point& other) const{
        if(other.x == x) return y < other.y;
        else return x < other.x;
    }
};

int n;
vector<Point> points;
vector<Point> down;
vector<Point> up;

bool ccw(Point a, Point b, Point c){
    long long t = (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);
    if(t <= 0) return false;
    else return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    points = vector<Point>(n);
    for(int i = 0; i < n; i++){
        cin >> points[i].x >> points[i].y;
    }
    sort(points.begin(), points.end());
    down.push_back(points[0]);
    down.push_back(points[1]);
    for(int i = 2; i < n; i++){
        while(down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], points[i])){
            down.pop_back();
            if(down.size() == 1){
                break;
            }
        }
        down.push_back(points[i]);
    }
    up.push_back(points[n-1]);
    up.push_back(points[n-2]);
    for(int i = n-3; i >= 0; i--){
        while(up.size() >= 2 && !ccw(up[up.size()-2], up[up.size()-1], points[i])){
            up.pop_back();
        }
        up.push_back(points[i]);
    }

    cout << down.size()+up.size()-2;

    return 0;
}
```
