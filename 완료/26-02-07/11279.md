# 11279번: 최대 힙

## 문제 요약
### 문제
널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.
1. 배열에 자연수 x를 넣는다.
2. 배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.
프로그램은 처음에 비어있는 배열에서 시작하게 된다.

### 사용 알고리즘
최대 힙

### 입출력
- 입력: 첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 2^31보다 작다.
- 출력: 입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.
```
예제1

입력
13
0
1
2
0
0
3
2
1
0
0
0
0
0
출력
0
2
1
3
2
1
0
0
```
## 풀이
이미 구현되어있는것을 가져다 써도 풀리겠지만 내가 집접 구현하는게 이 문제의 목적이라 생각하여 직접 구현했다. 

## 어려웠던 점
최대힙의 pop 함수를 짜는게 생각보다 힘들었다.

## 배운 점 / 느낀 점
pop에서 child를 일단 t*2로 정하고 chlid+1이 있다면 그것과 크기를 비교하여 구하는게 더 쉽다는 것을 알게 되었다.

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class pq{
    private:
        int data[100009];
        int idx;
    public:
        pq() : idx(0) {}
        bool empty(){
            return idx == 0;
        }
        void push(int k){
            idx++;
            data[idx] = k;
            int t = idx;
            while(t != 1 && data[t/2] < data[t]){
                int temp = data[t/2];
                data[t/2] = data[t];
                data[t] = temp;
                t/=2;
            }
        }
        int pop(){
            int r = data[1];
            data[1] = data[idx--];
            int t = 1;
            while(t <= idx/2){
                if(t*2+1 <= idx){
                    if(max(data[t*2], data[t*2+1]) <= data[t]){
                        break;
                    }
                    else if(data[t*2] < data[t*2+1]){
                        int temp = data[t*2+1];
                        data[t*2+1] = data[t];
                        data[t] = temp;
                        t*=2;
                        t++;
                    }
                    else{
                        int temp = data[t*2];
                        data[t*2] = data[t];
                        data[t] = temp;
                        t*=2;
                    }
                }
                else if(t*2 == idx){
                    if(data[2*t] > data[t]){
                        int temp = data[t*2];
                        data[t*2] = data[t];
                        data[t] = temp;
                    }
                    break;
                }
            }
            return r;

        }
};

int n;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    pq q;

    for (int i = 0; i < n; i++) {
        int k;
        cin >> k;
        if(k == 0){
            if(q.empty()) cout << 0 << '\n';
            else cout << q.pop() << '\n';
        }
        else q.push(k);
    }

    return 0;
}
```
