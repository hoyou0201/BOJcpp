# 1799번: 비숍

## 문제 요약
### 문제
서양 장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. < 그림 1 >과 같은 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.
그런데 체스판 위에는 비숍이 놓일 수 없는 곳이 있다. < 그림 2 >에서 체스판에 색칠된 부분은 비숍이 놓일 수 없다고 하자. 이와 같은 체스판에 서로가 서로를 잡을 수 없도록 하면서 비숍을 놓는다면 < 그림 3 >과 같이 최대 7개의 비숍을 놓을 수 있다. 색칠된 부분에는 비숍이 놓일 수 없지만 지나갈 수는 있다.
정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.

### 사용 알고리즘
dfs, 백트래킹

### 입출력
- 입력: 첫째 줄에 체스판의 크기가 주어진다. 체스판의 크기는 10이하의 자연수이다. 둘째 줄부터 아래의 예와 같이 체스판의 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 체스판 한 줄 단위로 한 줄씩 주어진다. 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0이 빈칸을 사이에 두고 주어진다.
- 출력: 첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.
```
예제1

입력
5
1 1 0 1 1
0 1 0 0 0
1 0 1 0 1
1 0 0 0 0
1 0 1 1 1
출력
7
```
## 풀이
흑백 비숍은 서로의 영역을 침범할 수 없으므로 나눠서 푸는게 좋다. 오른쪽 아래로 내려가는 대각선을 기준으로 하나씩 넣어보며 진행한다. 가장 왼쪽 아래에 있는 대각선부터 오른쪽 위에 있는 대각선까지 한칸씩 올라가며 그 대각선에 들어갈 수 있는 비숍들을 하나씩 넣어본다. 아예 안 넣는 경우도 생각한다. 그리고 오른쪽 위로 가는 대각선을 bool 배열로 만들어 겹치는지 확인한다. 체스판을 그대로 받기보다는 1인 구역만 받는게 좋다.

## 어려웠던 점
아이디어 떠올리는게 어려웠다. 흑백을 나누는걸 생각했어도 어려웠겠다는 생각이 들었다.

## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n;
vector<vector<pair<int,int>>> black_ru;
vector<bool> black_rd;
vector<vector<pair<int,int>>> white_ru;
vector<bool> white_rd;
vector<bool> u,d;

int ru(int i, int j){
    return i+j;
}
int rd(int i, int j){
    return j-i+n-1;
}

int black_dfs(int idx){
    int cnt = 0;
    if(idx >= n*2-1) return 0;
    for(auto [i, j] : black_ru[idx]){
        if(!black_rd[rd(i,j)]){
            black_rd[rd(i,j)] = true;
            cnt = max(black_dfs(idx+2)+1, cnt);
            black_rd[rd(i,j)] = false;
        }
    }
    return max(cnt, black_dfs(idx+2));
}

int white_dfs(int idx){
    int cnt = 0;
    if(idx >= n*2-1) return 0;
    for(auto [i, j] : white_ru[idx]){
        if(!white_rd[rd(i,j)]){
            white_rd[rd(i,j)] = true;
            cnt = max(white_dfs(idx+2)+1, cnt);
            white_rd[rd(i,j)] = false;
        }
    }
    return max(cnt, white_dfs(idx+2));
}



int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    black_ru = vector<vector<pair<int,int>>>(2*n);
    black_rd = vector<bool>(2*n);
    white_ru = vector<vector<pair<int,int>>>(2*n);
    white_rd = vector<bool>(2*n);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            int a;
            cin >> a;
            if(a){
                if((i+j)%2 == 0) black_ru[ru(i,j)].emplace_back(i, j);
                else white_ru[ru(i,j)].emplace_back(i, j);
            }
        }
    }

    cout << black_dfs(0) + white_dfs(1);






    return 0;
}
```
