# 2162번: 선분 그룹

## 문제 요약
### 문제
N개의 선분들이 2차원 평면상에 주어져 있다. 선분은 양 끝점의 x, y 좌표로 표현이 된다.
두 선분이 서로 만나는 경우에, 두 선분은 같은 그룹에 속한다고 정의하며, 그룹의 크기는 그 그룹에 속한 선분의 개수로 정의한다. 두 선분이 만난다는 것은 선분의 끝점을 스치듯이 만나는 경우도 포함하는 것으로 한다.
N개의 선분들이 주어졌을 때, 이 선분들은 총 몇 개의 그룹으로 되어 있을까? 또, 가장 크기가 큰 그룹에 속한 선분의 개수는 몇 개일까? 이 두 가지를 구하는 프로그램을 작성해 보자.

### 사용 알고리즘
교차 판정, dsu

### 입출력
- 입력: 첫째 줄에 N(1 ≤ N ≤ 3,000)이 주어진다. 둘째 줄부터 N+1번째 줄에는 양 끝점의 좌표가 x1, y1, x2, y2의 순서로 주어진다. 각 좌표의 절댓값은 5,000을 넘지 않으며, 입력되는 좌표 사이에는 빈칸이 하나 있다.
- 출력: 첫째 줄에 그룹의 수를, 둘째 줄에 가장 크기가 큰 그룹에 속한 선분의 개수를 출력한다.
```
예제1

입력
3
1 1 2 3
2 1 0 0
1 0 1 1
출력
1
3
```
## 풀이
선분 교차 판정을 하며 그룹으로 묶는것을 하면 된다. 각각은 생각보다 어렵지 않다.

## 어려웠던 점
선분 교차 판정이 어려웠다. 

## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct point{
    long long x, y;
};

struct line {
    point s, e;
};

int n;
vector<line> lines;
vector<int> parent;
vector<int> cnt;

int ccw(point a, point b, point c){
    long long k = (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);
    if(k > 0) return 1;
    else if (k < 0) return -1;
    else return 0;
}

bool in_box(point a, point b, point c){
    return (min(a.x, b.x) <= c.x && c.x <= max(a.x, b.x)
        && min(a.y, b.y) <= c.y && c.y <= max(a.y, b.y));
}

bool is_cross(line a, line b){
    int t1 = ccw(a.s, a.e, b.s);
    int t2 = ccw(a.s, a.e, b.e);
    int t3 = ccw(b.s, b.e, a.s);
    int t4 = ccw(b.s, b.e, a.e);
    
    if(t1 == 0 && in_box(a.s, a.e, b.s)) return true;
    if(t2 == 0 && in_box(a.s, a.e, b.e)) return true;
    if(t3 == 0 && in_box(b.s, b.e, a.s)) return true;
    if(t4 == 0 && in_box(b.s, b.e, a.e)) return true;

    return (t1*t2 < 0 && t3*t4 < 0);
}

int find(int x){
    if(parent[x] == x) return x;
    else{
        return parent[x] = find(parent[x]);
    }
}

void unite(int a, int b){
    a = find(a);
    b = find(b);

    if(a != b){
        parent[a] = b;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    lines = vector<line>(n);
    parent = vector<int>(n);
    cnt = vector<int>(n);

    for (int i = 0; i < n; i++) {
        cin >> lines[i].s.x >> lines[i].s.y >> lines[i].e.x >> lines[i].e.y;
        parent[i] = i;
    }

    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            if(is_cross(lines[i], lines[j])){
                unite(i, j);
            }
        }
    }

    for (int i = 0; i < n; i++) {
        cnt[find(i)]++;
    }
    int r = 0, m = 0;
    for (int i = 0; i < n; i++) {
        if(cnt[i]){
            m = max(m, cnt[i]);
            r++;
        }
    }
    cout << r << ' ' << m;

    return 0;
}
```
