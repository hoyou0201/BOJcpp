# 13549번: 숨바꼭질 3

## 문제 요약
### 문제
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

### 사용 알고리즘
BFS

### 입출력
- 입력: 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.
- 출력: 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.
```
예제1

입력
5 17
출력
2
```
## 풀이
BFS로 푸는 문제이다. 2배 이동은 0초가 걸리므로 2배 이동하는 것들을 한 묶음으로 보고 그 다음 앞뒤로 한 칸 씩 이동하는 것을 다음 스탭으로 본다. 큐를 짤때 불필요한 스탭 수를 넣지 않기 위해서 큐의 값을 벡터로 하였다. 벡터에 그전단계에서 한칸씩 이동한 것들을 넣고 그다음 큐에서 그것이 나오면 2배씩 이동하며 원하는 값이 있는지 찾았다. 

## 어려웠던 점
처음엔 동적계획 문제인가 싶어서 잘못 풀었다.

## 배운 점 / 느낀 점
0-1 bfs에 대하여 배웠다. 내가 짠 것보다 훨씬 좋은 방법이다. 기본적인 아이디어는 비용이 0이면 큐의 앞에 추가, 1이면 큐의 뒤에 추가이다. 큐의 값들이 정렬되어있다고 할때 비용이 0인것을 앞에 넣으면 이전것과 비용을 추가해도 값이 같으므로 정렬이 유지된다. 또한 비용이 1인것은 당연히 뒤에 추가하면 정렬되어 존재한다. 큐의 가장 앞과 가장 뒤가 항상 1차이나게 되는데 왜냐하면 2차이나는 값은 들어갈 수 없기 때문이다. 따라서 dist 배열을 추가해서 처음 위치에서 거리를 모두 큰 수로 정의해놓고 0-1 bfs를 사용하면 쉽게 풀 수 있다. 이때 +연산은 -보다 뒤에 들어가야 한다. 0-1bfs는 최단거리를 보장하지 않는데 2배씩 이동하는것이 가장 좋고 2배씩 이동하는 것은 +방향이므로 -1을 빼는것이 그 다음으로 좋고 +1이 마지막이다

## 전체 코드
### 처음 푼 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;

int n, k;
queue<vector<int>> q = queue<vector<int>>();
vector<bool> v = vector<bool>(100001);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n >> k;
    int t = 0;
    q.push({n});
    while(!q.empty()){
        vector<int> ve = q.front();
        stack<int> ne = stack<int>();
        vector<int> nne = vector<int>();
        q.pop();
        for(int i : ve){
            int p = i;
            v[p] = true;
            if(p == k){
                cout << t;
                return 0;
            }
            ne.push(p);
            p*= 2;
            while(p < 100001){
                if(v[p]){
                    break;
                }
                v[p] = true;
                if(p == k){
                    cout << t;
                    return 0;
                }
                ne.push(p);
                p*=2;
            }
        }
        while(!ne.empty()){
            int i = ne.top();
            ne.pop();
            if(i+1 < 100001 && !v[i+1]){
                nne.push_back(i+1);
                v[i+1]=true;
            }
            if(i-1 >= 0 && !v[i-1]){
                nne.push_back(i-1);
                v[i-1]=true;
            }
        }
        if(!nne.empty()) q.push(nne);
        t += 1;

    }

    

    return 0;
}
```
### 0-1 bfs
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <deque>
using namespace std;

int n, k;
deque<int> q = deque<int>();
vector<int> d = vector<int>(100001, 200000);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n >> k;
    if(n == k){
        cout << 0;
        return 0;
    }
    q.push_back(n);
    d[n] = 0;
    while(!q.empty()){
        int i = q.front();
        q.pop_front();

        if(i*2 < 100001 && d[i*2] > d[i]){
            d[i*2] = d[i];
            if(i*2==k){
                cout << d[i*2];
                return 0;
            }
            q.push_front(i*2);
        }
        if(i-1 >= 0 && d[i-1] > d[i]){
            d[i-1] = d[i]+1;
            if(i-1==k){
                cout << d[i-1];
                return 0;
            }
            q.push_back(i-1);
        }

        if(i+1 < 100001 && d[i+1] > d[i]){
            d[i+1] = d[i]+1;
            if(i+1==k){
                cout << d[i+1];
                return 0;
            }
            q.push_back(i+1);
        }
        
    }
    
    return 0;
}
```