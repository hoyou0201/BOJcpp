# 16565번: N포커

## 문제 요약
### 문제
정연이는 트럼프 카드 (Playing Card)로 할 수 있는 새로운 게임을 만들기로 결심했다.
우선 이 게임은 딜러와 플레이어가 1:1로 플레이한다. 그리고 플레이어는 놓여진 52장의 트럼프 카드에서 N장의 카드를 뽑는다. 뽑은 카드들로 "포카드 (four of a kind)" 족보를 만들 수 있다면 플레이어의 승리, 만들 수 없다면 딜러의 승리로 게임이 끝난다. 그러나 정연이는 아직 공정한 게임을 위한, 뽑는 카드의 수 N을 결정하지 못하였다.
정연이가 쉽게 결정을 내릴 수 있도록, N개의 카드를 뽑았을 때 플레이어가 이기는 경우의 수를 출력하는 프로그램을 작성해주자.
트럼프 카드는 다음과 같은 52장의 카드로 구성된다.
- Figure: 트럼프 카드 (Playing Card)의 구성
- 문양 4개: ♥, ♠, ◆, ♣, 숫자 13개: A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K
- 총 4 x 13 = 52장
포카드 (four of a kind)는 뽑은 N장의 카드 중에 "같은 숫자를 가진, 다른 문양의 4장의 카드"가 존재하는 경우를 의미한다. 또한 플레이어가 이기는 경우의 수는 N장의 카드에 이러한 카드 조합을 1쌍 이상 포함하고 있는 경우의 수를 의미한다.

### 사용 알고리즘
조합, dp

### 입출력
- 입력: 첫째 줄에 뽑는 카드의 수 N이 주어진다. (1 ≤ N ≤ 52)
- 출력: 첫째 줄에 N장의 카드를 뽑았을 때, 플레이어가 이기는 경우의 수를 10,007로 나눈 나머지를 출력하라.
```
예제1

입력
4
출력
13
```
## 풀이
조합 문제 이다. 조합은 간단한 수학으로 풀 수 있는데 구현이 살짝 어려웠다. 처음에는 단순 계산으로 하다가 나눗셈은 모듈러 계산이 안된다는 것을 알고 파스칼의 삼각형을 만들었다.

## 어려웠던 점


## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n;
vector<vector<int>> c;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;

    c.push_back({1});
    for (int i = 1; i < 52; i++) {
        c.push_back(vector<int>(i+1));
        for (int j = 0; j < i+1; j++) {
            if(j == 0 || j == i){
                c[i][j] = 1;
            }
            else{
                c[i][j] = (c[i-1][j-1]+c[i-1][j])%10007;
            }
        }
    }

    int k = 1;
    int r = 0;
    while(k*4 <= n){
        int g = c[13][k];
        int t = c[52-k*4][n-k*4];
        if(k%2 == 1){
            r += (g*t)%10007;
        }
        else{
            r -= (g*t)%10007;
            r = (r+10007)%10007;
        }
        k++;
    }
    cout << (r+10007)%10007;

    return 0;
}
```
