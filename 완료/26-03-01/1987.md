# 1987번: 알파벳

## 문제 요약
### 문제
세로 $R$칸, 가로 $C$칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 ($1$행 $1$열) 에는 말이 놓여 있다.
말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.
좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.

### 사용 알고리즘
DFS, 비트마스크

### 입출력
- 입력: 첫째 줄에 $R$과 $C$가 빈칸을 사이에 두고 주어진다. ($1 ≤ R,C ≤ 20$) 둘째 줄부터 $R$개의 줄에 걸쳐서 보드에 적혀 있는 $C$개의 대문자 알파벳들이 빈칸 없이 주어진다.
- 출력: 첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.
```
예제1

입력
2 4
CAAB
ADCB
출력
3
```
## 풀이
dfs를 이용하여 최대 경로를 구하면 된다. 이때 왔던곳을 판단하는 것은 비트마스크를 이용해야 풀린다.

## 어려웠던 점


## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int r, c;
vector<vector<int>> al;

int dfs(int mask, int y, int x){
    int mx = 0;
    if(y > 0 && !(mask & al[y-1][x])) mx = max(mx, dfs(mask|al[y-1][x], y-1, x));
    if(x > 0 && !(mask & al[y][x-1])) mx = max(mx, dfs(mask|al[y][x-1], y, x-1));
    if(y < r-1 && !(mask & al[y+1][x])) mx = max(mx, dfs(mask|al[y+1][x], y+1, x));
    if(x < c-1 && !(mask & al[y][x+1])) mx = max(mx, dfs(mask|al[y][x+1], y, x+1));
    return mx+1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> r >> c;

    al = vector<vector<int>>(r, vector<int>(c));

    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            char t;
            cin >> t;
            al[i][j] = 1<<(t-'A');
        }
    }

    cout << dfs(al[0][0], 0, 0);

    return 0;
}
```
