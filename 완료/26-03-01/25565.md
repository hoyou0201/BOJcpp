# 25565번: 딸기와 토마토

## 문제 요약
### 문제
즈티와 레오가 사는 집 앞마당에는 $N\times M$ 크기의 작은 텃밭이 있다. 텃밭의 좌측 상단의 좌표는 $(1, 1)$이며, 우측 하단의 좌표는 $(N, M)$이다. 텅 빈 텃밭이 허전해 보인 둘은 각자 원하는 작물을 텃밭에 심고 예쁘게 키워보기로 했다. 즈티는 $K$칸 이상인 가로 또는 세로 줄 하나를 고른 후 그 줄에서 임의의 연속한 $K$개의 칸에 모두 딸기 씨앗을 심었고, 레오는 같은 방법으로 토마토 씨앗을 심었다. 텃밭을 벗어나서 씨앗을 심을 수는 없다. 텃밭의 각 칸에 종류와 상관없이 씨앗이 존재하는지가 주어질 때, 딸기와 토마토가 같이 자랄 칸의 좌표를 전부 구해보자. 단, 씨앗에서 작물이 자라지 않는 경우는 없으며, 조건에 맞는 입력만 주어진다.

### 사용 알고리즘
구현

### 입출력
- 입력: 첫 번째 줄에 $N, M, K$가 공백으로 구분되어 주어진다. $(1 \le N,M \le 2\,000, 1 \le K \le \max(N,M))$ 
두 번째 줄부터 $N$개의 줄에 각 칸의 씨앗 존재 여부를 나타내는 $M$개의 정수가 공백으로 구분되어 주어진다. $1$은 씨앗이 존재한다는 것, $0$은 존재하지 않는다는 것을 의미한다.
- 출력: 첫 번째 줄에 딸기와 토마토가 같이 자랄 칸의 수를 출력한다.
딸기와 토마토가 같이 자랄 칸이 한 개 이상이라면, 두 번째 줄부터 한 줄에 하나씩 딸기와 토마토가 같이 자랄 칸의 좌표를 첫 번째 좌표가 증가하는 순으로, 첫 번째 좌표가 같으면 두 번째 좌표가 증가하는 순으로 출력한다.
```
예제1

입력
3 4 3
0 1 0 0
0 1 1 1
0 1 0 0
출력
1
2 2
```
## 풀이
구현 문제이다. 일단 개수를 세서 2k와 같으면 당연히 겹치는게 없는것이고 1인경우에는 십자에 겹쳤을수도 있다. 이로직을 짜면 되고 이때 걸리지 않았거나 1보다 크다면 직선으로 겹쳐있는 것이다. 직선을 찾아 겹치는 부분만 출력하면 된다.

## 어려웠던 점
겹치는 부분 찾는게 힘들었다.

## 배운 점 / 느낀 점


## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n, m, k, cnt;
vector<vector<int>> tt;
vector<pair<int,int>> ga, se;
pair<int,int> f;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n >> m >> k;

    tt = vector<vector<int>>(n+1, vector<int>(m+1));
    f = {0,0};

    for(int i = 1; i < n+1; i++){
        for(int j = 1; j < m+1; j++){
            cin >> tt[i][j];
            if(tt[i][j] == 1){
                if(f.first == 0){
                    f = {i,j};
                }
                cnt++;
            }
        }
    }

    if(cnt == 2*k){
        cout << 0;
        return 0;
    }
    else if(cnt == 2*k-1){
        for(int i = 1; i < n+1; i++){
            for(int j = 1; j < m+1; j++){
                if(tt[i][j] && (i > 1 && tt[i-1][j] || i < n && tt[i+1][j]) && (j > 1 && tt[i][j-1] || j < m && tt[i][j+1])){
                    cout << 1 << '\n' << i <<' ' << j;
                    return 0;
                }
            }
        }
    }
    int ccc = 2*k-cnt;
    int offset = k-ccc;
    if(f.first < n && tt[f.first+1][f.second]){
        cout << ccc << '\n';
        for(int i = f.first+offset; i < f.first+offset+ccc; i++){
            cout << i << ' ' << f.second << '\n';
        }
    }
    else{
        cout << ccc << '\n';
        for(int i = f.second+offset; i < f.second+offset+ccc; i++){
            cout << f.first << ' ' << i << '\n';
        }
    }

    return 0;
}
```
