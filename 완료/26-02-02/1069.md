# 1069번: 집으로

## 문제 요약
### 문제
은진이는 지금 (X, Y)에 있고, (0, 0)에 있는 집으로 가능한 빨리 가려고 한다. 이동할 수 있는 방법은 다음 두 가지이다.
첫 번째 방법은 걷는것이다. 걸을 때는 1초에 1만큼 움직인다. 두 번째 방법은 점프하는 것이다. 점프를 하게 되면, T초에 D만큼 움직인다. 점프는 일직선으로만 할 수 있고, 정확하게 D칸만 움직일 수 있다.
위의 두 가지 방법을 이용해서 집에 돌아오는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오. 꼭 한 가지 방법만 사용해야 되는것이 아니고, 두 가지 방법을 적절히 조합해서 가장 빠른 시간을 구하는 것이다.

### 사용 알고리즘
기하학

### 입출력
- 입력: 첫째 줄에 네 정수 X, Y, D, T가 주어진다.
- 출력: 첫째 줄에 집에 돌아오는데 걸리는 시간의 최솟값을 출력한다. 절대/상대 오차는 10-9까지 허용한다.
```
예제1

입력
6 8 5 3
출력
6.0
```
## 풀이
분기가 많다. 먼저 원점까지 직선거리를 구하고 점프하는게 일반 이동속도보다 느리다면 그 거리가 답이 된다. 점프가 빠르다면 최대한 점프를 하고 남은 값만큼 간다. 그리고 최대치보다 한번 적게 점프하고 남은 두번을 V자로 이동하여 원점으로 이동한다. 둘을 비교해서 더 적은게 답이 된다. 이때 최대로 점프하는게 0번이라면 다른 경우로 분기된다. 0번이라면 V자가 처음부터 시도해야하므로 시작점에서 점프 두번의 값을 비교한다. 또한 직선으로 한번 이동하고 되돌아 올 수도 있으므로 그 값도 비교한다.

## 어려웠던 점
분기가 많아 헷갈렸다.

## 배운 점 / 느낀 점
sqrt함수, 고정소수점 표현법, 1.0곱해서 실수값 반환하게 하는법

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;

int x, y, t, d;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> x >> y >> d >> t;

    double dist = sqrt(1.0*x*x+1.0*y*y);

    if((1.0*d)/t < 1){
        cout << fixed << setprecision(15) << dist;
    }

    int k = dist/d;

    double ans = t*k + fmod(dist, d);
    if(k == 0){
        ans = min(ans, 1.0*t+d-fmod(dist, d));
        ans = min(ans, 2.0*t);
    }
    else ans = min(ans, 1.0*t*(k+1));
    
    cout << fixed << setprecision(15) << ans;

    return 0;
}
```
